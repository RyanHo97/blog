# Redis设置key的过期时间和原理

## 1、应用场景

- 手机验证码自动失效过期
- 缓存自动失效
  - 什么是缓存 数据暂时性的存储 数据在内存中的备份 为访问速度更快



缓存需要关闭redis的自动持久化

不能持久化 没有事务





1.设置过期时间 **expire**

expire name 10 单位秒

pexpire age 10000 单位毫秒



2.查看剩余时间

ttl name 单位秒

pttl name 单位毫秒



3.取消过期

persist age

ttl返回-1表示没有设置过期时间，返回-2表示数据不存在









## 2、过期策略

问题1：

在Redis中，所有设置了过期时间的key，会被放在一个map（字典）中。

- Redis如何发现key过期了呢？

  遍历 所有key 一个一个查看时间有没有过期 不是遍历所有

- 会不会有很多的key在同一时间过期？存在大量key需要删除的时候，Redis能忙过来吗？会不会因为要删除的key太多而卡死》

  不会，Redis不会再key过期的时候立马删除，而是采用两种策略：

  1. 定期删除，定期遍历，每秒遍历10次过期key的集合
  2. 惰性删除，客户端访问这个key的时候，redis对key的过期时间进行检查，如果过期了就立即删除。



### 定期删除策略：

Redis默认会每秒进行十次过期扫描，过期扫描不会遍历过期字典中所有的key，而是采用了一种简单的策略。

1.从过期字典中随机20（若）个key；

2.删除这20个key中已经过期的key；

3.如果过期的key比率超过1/4.那就重复步骤1；

同时，为了保证过期扫描不会出现循环过度，导致线程卡死现象，算法还增加了扫描时间的上限，默认不会超过25ms。



问题2：

如果一个key非常的幸运，没有被定期删除，也没有被查询（意味着惰性删除也不生效），那么这个key是不是就会永远的占用Redis的内存了？？？？

答案：不会，随着Redis的内存越来越高，Redis会执行内存淘汰机制，删除部分的key。



### 内存淘汰机制：

在redis.conf中有一行配置

- volatile Java中的一个关键字

#maxmemory-policy volatile-lru



lru 算法 最新最少 自动寻找最晚放进去最少使用的元素

